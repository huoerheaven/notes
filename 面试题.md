##### 1. 数组深度扁平化
```js
/**
 * 数组深度扁平化 concat+apply
 * @param {*} arr 
 * @returns 
 */
function flat1(arr){
    //验证arr中，还有没有深层数组[1,2,[3,4]]
    const isDeep = arr.some(item=>item instanceof Array);
    if(!isDeep){
        return arr;
    }
    // 利用array.concat()递归拍平 和 apply的接收的第二个参数必须是数组形式
    const res = Array.prototype.concat.apply([],arr);
    return flat(res);

}

/**
 * 数组深度扁平化 递归 concat+push
 * @param {*} arr 
 * @returns 
 */
function flat2(arr){
    let res=[];
    for(let i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){
            res=res.concat(flat2(arr[i]))
        }else{
            res.push(arr[i]);
        }
    }
    return res;
}

console.log(flat2([1,2,3,[4,5,[6]]]));//[1,2,3,4,5,6]
```

##### 2. 获取详细的数据类型
```js
/**
 * 获取详细的数据类型
 * 注意：Object.prototype.toString.call(2) ===》 "[Object Number]"  调的是最原始的toString方法  
 * @param {*} x 
 */
function getType(x){
    const originType = Object.prototype.toString.call(x);
    const spaceIndex = originType.indexOf(" ");
    const type = originType.slice(spaceIndex+1,-1);
    return type.toLowerCase();
}

console.log(getType(null));//null
console.log(getType(undefined));//undefined
console.log(getType(11));//number
console.log(getType("aa"));//string
console.log(getType(true));//boolean
console.log(getType([]));//array
console.log(getType({}));//object
console.log(getType(()=>{}));//function
console.log(getType(Symbol()));//symbol
console.log(getType(new Set()));//set
console.log(getType(new Map()));//map
console.log(getType(new WeakMap()));//weakmap
```

##### 3. 实现new
```js
/**
 * 实现new
 * @param {*} constructor 
 * @param  {...any} args 
 * @returns 
 */
function customNew(constructor,...args){
    //1. 创建一个空对象，继承构造函数的原型
    const obj = Object.create(constructor.prototype);
    //2. 将obj作为this,执行constructor,传入参数
    constructor.apply(obj,args);
    //3. 返回 obj
    return obj;
}

function Foo(name,age){
    this.name=name;
    this.age=age;
    this.getName=function(){
        return this.name
    }
}

// const f=new Foo("weiwie",11)
// console.log(f)

const f = customNew(Foo,"weiwei",33)
console.log(f)
```

##### 4. 遍历dom tree
```js
/**
 * 访问节点
 * @param {*} node node
 */
function visitNode(node){
    if(node instanceof Comment){
        //注释
        console.info("Comment node --- ",node.textContent);
    }
    if(node instanceof Text){
        //文本
        const t = node.textContent?.trim();
        if(t){
            console.info("Text node --- ",node.textContent?.trim());
        }
    }
    if(node instanceof HTMLElement){
        //element
        console.log("Element node --- ",`<${node.tagName.toLowerCase()}>`);
    }
}

/**
 * 深度优先遍历
 * @param {*} root  dom node
 */
function depthFirstTraverse(root){
    if(!root) return ;
    visitNode(root);
    const childNodes = root.childNodes;//.childNodes（包括标签 文本 注释） 和 .children（只包括标签，不包括文本和注释）不一样
    if(childNodes.length){
        for(let i=0;i<childNodes.length;i++){
            depthFirstTraverse(childNodes[i]);//递归
        }
    }

}
//test
let app = document.getElementsByClassName("app")[0];
if(app==null) throw new Error("app is null");
depthFirstTraverse(app);
//输出结果为：
Element node ---  <div>
Comment node ---   这是注释 测试 dft
Element node ---  <p>
Text node ---  这是p标签
Text node ---  hello world

/**
 * 广度优先遍历
 * @param {*} root  dom node
 * @returns 
 */
function breadthFirstTraverse(root){
    if(!root) return ;
    const queue=[];
    //根节点入队列
    queue.unshift(root);
    while(queue.length>0){
        const currNode = queue.pop();
        if(currNode==null) break;
        visitNode(currNode);
        //子节点入队列
        const childNodes = currNode.childNodes;//.childNodes（包括标签 文本 注释） 和 .children（只包括标签，不包括文本和注释）不一样
        if(childNodes.length){
            for(let i=0;i<childNodes.length;i++){
                queue.unshift(childNodes[i]);
            }
        }
    }
}
//test
breadthFirstTraverse(app);
//输出结果为：
Element node ---  <div>
Comment node ---   这是注释 测试 dft
Element node ---  <p>
Text node ---  hello world
Text node ---  这是p标签
```
- 划重点：
- - 深度优先，递归，贪心
- - 广度优先，使用队列（数组vs链表）
- - children 和 childNodes不同
- 连环问：深度优先遍历可以不用递归吗
- - 可以不用递归，用**栈**
- - 因为递归本身就是栈
```js
/**
 * 深度优先遍历（用栈实现）
 * @param {*} root  dom node
 */
function depthFirstTraverse2(root){
    if(!root) return;
    const stack=[];
    stack.push(root);
    while(stack.length>0){
        const currNode = stack.pop();
        if(currNode==null) break;
        visitNode(currNode);
        const childNodes = currNode.childNodes;
        if(childNodes.length){
            //reverse反顺序压栈
            Array.from(childNodes).reverse().forEach(item=>stack.push(item))
        }
    }
}
//test
depthFirstTraverse2(app)
//输出结果为：
Element node ---  <div>
Comment node ---   这是注释 测试 dft
Element node ---  <p>
Text node ---  这是p标签
Text node ---  hello world
```
