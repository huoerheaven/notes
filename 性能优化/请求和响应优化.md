#### 最佳实践
1. **减少DNS查找**：每次主机名的解析都需要一次网络往返，从而增加了请求的延时时间，同时还会阻塞后续的请求。
2. **重用TCP连接**：尽可能的使用持久连接，以消除TCP握手和慢启动导致的延迟。
3. **减少HTTP重定向**：HTTP重定向需要额外的DNS查询、TCP握手等非常耗时，最佳的重定向次数为0。
4. **呀说传输的资源**：比如Gzip、图片压缩。
5. **使用缓存**：比如HTTP缓存、CDN缓存、Service Worker缓存。
6. **使用CDN（内容分发网络）**：把数据放在离用户地理位置更近的地方，可以明显减少每次TCP连接的网络延迟，增大吞吐量。
7. **删除没有必要请求的资源**。
8. **在客户端缓存资源**：缓存必要的应用资源，避免每次都重复请求相同的内容，例如多图片下载可以考虑缓存。
9. **内容在传输前先压缩**：传输数据之前应该先压缩应用资源，把要传输的字节减少到最小。
10. **消除不必要的请求开销**：减少请求的HTTP首部数据（比如 HTTP COOKIE）.
11. **并行处理请求和响应**:请求和响应的排队都会导致延迟，可以尝试并行的处理请求和响应（利用多个HTTP1.1连接实现并行下载，在可能的情况下使用HTTP管道计数）。
12. **针对协议版本采取优化措施**：升级到HTTP2.0
13. **根据需要采用服务端渲染方式**：这种方式可以解决SPA应用首屏渲染慢的问题。
14. **采用预渲染的方式快速加载静态资源**：页面渲染的极致性能，比较适合静态页面。

#### 长连接
1. HTTP1.1 版的最大变化，就是引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明`ConnectionLkeep-alive`.
- 持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早的结束，这样Web页面的显示速度也就相应提高了。
- 对于同一个域名，大多数浏览器允许同时建立6个持久连接。
2. 管道机制
- HTTP1.1版还引入了管道机制（pipelining）,即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。
3. 缺点：
- 虽然HTTP1.1版允许复用TCP连接，但是同一个TCP连接里面，所有数据通信是按次序及逆行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着，这称为“对头堵塞”。
- 解决方法：
- - 1. 减少请求数，比如合并脚本和样式表，将图片嵌入css代码等
- - 2. 同时多开持久连接，比如域名分片等

#### HTTP2
1. 二进制协议
- HTTP1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。
- HTTP2则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”（frame）：头信息帧和数据帧。
2. 多工
- HTTP2复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了“对头堵塞”。
- 这样双向的、实时的通信，就叫多工（Multiplexing）。
3. 数据流
- 因为HTTP2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须对数据包做标记，指出它属于哪个回应。
- HTTP2将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的为偶数。
- 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早响应。
4. 头信息压缩
- HTTP协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。
- HTTP2对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务端同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发生那个索引号，这样就提高速度了。
5. 服务器推送
- HTTP2允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）

#### 压缩传输的数据资源
1. HTTP响应数据压缩
- 使用Gzip压缩文本
- - 1. 请求头中：Accept-Encoding:gzip,deflate,br
- - 2. 响应头：Content-Encoding:gzip
2. HTTP请求数据压缩
- 头部数据压缩（HTTP2 头信息压缩机制（header compression））
- 请求体数据压缩

#### HTTP缓存
1. 强制缓存
- `Expires:过期时间`（http1.0）
- cache-control
- 1. max-age=10 //滑动事件，单位是秒
- 2. no-cache 
- - 设置`no-cache`并非像字面上的意思不使用缓存，其表示为强制进行协商缓存，即对于每次发起的请求都不会再去判断强制缓存是否过期，而是直接与服务器协商来验证缓存的有效性。若缓存未过期，则会使用本地缓存。
- 3. no-store 
- - `no-store`则表示禁止使用任何缓存策略，客户端的每次请求都需要服务端给予全新的响应。
- 4. no-cache 和 no-store是两个互斥的属性值，不能同时设置。
- 5. private 和 public 
- - `private` 和 `public` 也是`cache-control`的一组互斥属性值，它们用以明确响应资源是否可被代理服务器进行缓存。
- - 若资源响应头中的`cache-control`字段设置了`public`属性值，则表示响应资源既可以被浏览器缓存，又可以被代理服务器缓存。
- - `private`则限制了响应资源只能被浏览器缓存，若未显式指定则默认值为`private`。
- 6. max-age 和 s-maxage
- - `max-age` 表示服务器端告知客户端浏览器响应资源过期时长。
- - `s-maxage` 表示缓存在代理服务器中的过期时长，且仅当设置了`public`属性时才有效。

2. 协商缓存
- 1. 响应头中：last-modified
- 2. 请求头中：if-modified-since
- - 缺陷：
- - 1. 它只是根据资源最后的修改时间戳进行判断的，虽然请求的文件资源进行了编辑，但内容并没有发生任何变化，时间戳也会更新。从而导致协商缓存时关于有效性的判断验证为失效，需要重新进行完整的资源请求。这无疑会造成网络带宽资源的浪费，以及延长用户获取到目标资源的时间。
- - 2. 标识文件资源修改的时间戳单位时秒，如果文件修改的速度非常快，假设在几百毫秒内完成，那么上述通过时间戳的方式来验证缓存的有效性，是无法识别出该次文件资源的更新的。
- 3. 响应头中：ETag
- - 1. 其主要内容是服务器为不同资源进行哈希运算所生成的一个字符串，该字符串类似于文件指纹，只要文件内容编码存在差异，对应的ETag标签值就会不同，因此可以使用ETag对文件资源进行更精准的变化感知。
- -  缺陷
- - 1. 服务器对于生成文件资源的ETag需要付出额外的计算开销，如果资源的尺寸较大，数量较多且修改比较频繁，那么生成ETag的过程就会影响服务器的性能。
- - 2. ETag字段值的生成分为强验证和弱验证。强验证根据资源内容进行生成，能够保证每个字节都先相同；弱验证则根据资源的部分值来生成，会因为不够准确而降低协商缓存有效性。
- 4. 请求头中：If-None-Match

#### 缓存决策
- 1. HTML文件属于包含其他文件的主文件，为保证当其内容发生修改时能及时更新，应当将其设置为协商缓存。
- 2. 图片文件，因为网站对图片的修改基本都是更换修改，同时考虑到图片文件的数量及大小可能对客户端缓存空间造成不小的开销，所以可采用强制缓存且过期时间不宜过长，故可设置`cache-control`字段值为`max-age=86400`;
- 3. 样式表文件`style.css`,可以考虑在样式表文件的命名中增加文件指纹或版本号（`style.5f5asd34.css`），这样当文件发生修改后，不同的文件便有不同的文件指纹，则需求请求新的url,因此必然会对资源进行重新请求。同时考虑到网络中浏览器与CDN等中间代理的缓存，其过期时间可适当延长到一年，即`max-age=31536000`。
- 4. JavaScript脚本文件，可类似于样式表文件的设置，采取文件指纹和较长的过期时间。

#### CDN缓存

#### TCP连接的三次握手和四次挥手
- [详见](https://zhuanlan.zhihu.com/p/51560184)
