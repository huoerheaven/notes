#### GC 算法
1. GC 定义与作用
- GC 就是垃圾回收机制的简写
- GC 可以找到内存中的垃圾，并释放和回收空间

2. GC 算法是什么
- GC 是一种机制 ，垃圾回收器完成具体的工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则

3. 常见 GC 算法
- 引用计数
- - 核心思想：设置引用数，判断当前引用数是否为0
- - 引用计数器
- - 引用关系改变时修改引用数字
- - 引用数字为0时立即回收  
- 引用计数算法优点
- - 发现垃圾时立即回收
- - 最大限度减少程序暂停
- 引用计数算法缺点
- - 无法回收循环引用的对象
- - 资源消耗较大
```js
function fn(){
    const obj1={};
    const obj2={};
    obj1.name=obj2;
    obj2.name=obj1;
    return "循环引用"
}
fn();
//此时obj1和obj2不会被回收，因为它们各自引用
```
- - 时间开销大

- 标记清除
- - 核心思想：分标记和清除两个阶段完成
- - 遍历所有对象找标记活动对象
- - 遍历所有对象清除没有标记对象
- - 回收相应的空间
- 标记清除算法优点
- - 可以回收循环引用的对象
- 标记清除算法缺点
- - 容易产生碎片化空间，浪费空间
- - 不会立即回收垃圾对象

- 标记整理
- - 标记整理可以看作是标记清除的增强
- - 标记阶段的操作和标记清除一致
- - 清除阶段会先执行整理，移动对象位置
- 标记整理算法优点
- - 减少碎片化空间
- 标记整理算法缺点
- - 不会立即回收垃圾对象

- 分代回收

#### V8
- V8 是一款主流的 Javascript 执行引擎
- V8 采用即时编译
- V8 内存设限
1. V8 垃圾回收策略
- 采用分代回收的思想
- 内存分为新生代、老生代
- 针对不同对象采用不同算法
2. V8中常用的GC算法
- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量
3. V8 如何回收新生代对象
- V8 内存分配
- - V8 内存空间一分为二
- - 小空间用于存储新生代对象（32M|16M）
- - 新生代指的是存活时间较短的对象
- 新生代对象回收实现
- - 回收过程采用复制算法+标记整理
- - 新生代内存区分为二个等大小空间
- - 使用空间为From,空闲空间为To
- - 活动对象存储于From空间
- - 标记整理之后将活动对象拷贝至To
- - From与To交换空间完成释放
- 回收细节说明
- - 拷贝过程中可能出现晋升
- - 晋升就是新生代对象移动至老生代
- - 一轮GC 还存活的新生代需要晋升
- - To 空间的使用率超过25%

3. V8 如何回收老年代对象
- 老年代对象说明
- - 老年代对象存放在右侧老生代区域
- - 64位操作系统1.4G，32位操作系统700M
- - 老年代对象就是指存活时间较长的对象（比如全局作用域或闭包中的对象）
- 老年代对象回收实现
- 主要采用标记清除、标记整理、增量标记算法
- 首先使用标记清除实现垃圾空间的回收
- 采用标记整理进行空间优化
- 采用增量标记进行效率优化
4. 细节对比
- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不适合复制算法

#### 闭包
- 闭包是一种机制，通过私有执行上下文来保护当中的变量的机制。（不被外界干扰）；
- 我们也可以认为当我们创建的某一个执行上下文不被释放的时候就形成了闭包
- 保护、保存数据
- - 保护：当前上下文中的变量与其他上下文中的变量互不干扰
- - 保存：当前上下文中的数据（堆内存）被当前上下文以外的上下文中的变量所引用，这个数据就保存下来
- 函数调用形成了一个全新的私有上下文，在函数调用之后当前上下文不被释放就是闭包（或临时不被释放）。

#### 闭包垃圾回收
- 浏览器都自有垃圾回收（内存管理，V8为例）；
- 栈空间、堆空间；
- 堆：当前堆内存如果被占用，就不能被释放掉，但是我们如果确认后续不再使用这个内存里的数据，也可以自己主动置空，然后浏览器就会对其进行回收；
- 栈：当前上下文中是否有内容被其他上下文的变量所占用，如果有则无法释放（闭包）；

#### 防抖和节流
1. 为什么需要防抖和节流
- 在一些高频率事件触发的场景下我们不希望对应的事件处理函数多次执行
2. 场景
- 滚动事件
- 输入的模糊匹配
- 轮播图切换
- 点击操作
- ...
3. 浏览器默认情况下都会有自己的监听事件间隔（4-6ms）,如果检测到多次事件的监听执行，那么就会造成不必要的资源浪费。
4. 前置场景：界面上有一个按钮，我们可以连续多次点击
- 防抖：对于这个高频的操作来说，我们只希望识别一次点击，可以认为是第一次或最后一次；
- 节流：对于高频操作，我们可以自己来设置频率，让本来会执行很多次的事件触发，按照我们定义的频率减少触发的次数。
